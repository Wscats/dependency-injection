'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _util = require('util');

var _util2 = _interopRequireDefault(_util);

var _isIgnored = require('@commitlint/is-ignored');

var _isIgnored2 = _interopRequireDefault(_isIgnored);

var _parse = require('@commitlint/parse');

var _parse2 = _interopRequireDefault(_parse);

var _rules = require('@commitlint/rules');

var _rules2 = _interopRequireDefault(_rules);

var _lodash = require('lodash.topairs');

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var buildCommitMesage = function buildCommitMesage(_ref) {
	var header = _ref.header,
	    body = _ref.body,
	    footer = _ref.footer;

	var message = header;

	message = body ? `${message}\n\n${body}` : message;
	message = footer ? `${message}\n\n${footer}` : message;

	return message;
};

exports.default = function (message) {
	var $args = arguments;return new Promise(function ($return, $error) {
		var rules, opts, parsed, missing, names, invalid, results, errors, warnings, valid;
		rules = $args.length > 1 && $args[1] !== undefined ? $args[1] : {};
		opts = $args.length > 2 && $args[2] !== undefined ? $args[2] : {};

		// Found a wildcard match, skip
		if ((0, _isIgnored2.default)(message)) {
			return $return({
				valid: true,
				errors: [],
				warnings: [],
				input: message
			});
		}

		// Parse the commit message
		return Promise.resolve((0, _parse2.default)(message, undefined, opts.parserOpts)).then(function ($await_1) {
			try {
				parsed = $await_1;

				missing = Object.keys(rules).filter(function (name) {
					return typeof _rules2.default[name] !== 'function';
				});

				if (missing.length > 0) {
					names = Object.keys(_rules2.default);
					return $error(new RangeError(`Found missing rule names: ${missing.join(', ')}. Supported rule names are: ${names.join(', ')}`));
				}

				invalid = (0, _lodash2.default)(rules).map(function (_ref2) {
					var _ref3 = (0, _slicedToArray3.default)(_ref2, 2),
					    name = _ref3[0],
					    config = _ref3[1];

					if (!Array.isArray(config)) {
						return new Error(`config for rule ${name} must be array, received ${_util2.default.inspect(config)} of type ${typeof config}`);
					}

					var _config = (0, _slicedToArray3.default)(config, 2),
					    level = _config[0],
					    when = _config[1];

					if (typeof level !== 'number' || isNaN(level)) {
						return new Error(`level for rule ${name} must be number, received ${_util2.default.inspect(level)} of type ${typeof level}`);
					}

					if (level === 0 && config.length === 1) {
						return null;
					}

					if (config.length !== 2 && config.length !== 3) {
						return new Error(`config for rule ${name} must be 2 or 3 items long, received ${_util2.default.inspect(config)} of length ${config.length}`);
					}

					if (level < 0 || level > 2) {
						return new RangeError(`level for rule ${name} must be between 0 and 2, received ${_util2.default.inspect(level)}`);
					}

					if (typeof when !== 'string') {
						return new Error(`condition for rule ${name} must be string, received ${_util2.default.inspect(when)} of type ${typeof when}`);
					}

					if (when !== 'never' && when !== 'always') {
						return new Error(`condition for rule ${name} must be "always" or "never", received ${_util2.default.inspect(when)}`);
					}

					return null;
				}).filter(function (item) {
					return item instanceof Error;
				});

				if (invalid.length > 0) {
					return $error(new Error(invalid.map(function (i) {
						return i.message;
					}).join('\n')));
				}

				// Validate against all rules
				results = (0, _lodash2.default)(rules).filter(function (entry) {
					var _entry = (0, _slicedToArray3.default)(entry, 2),
					    _entry$ = (0, _slicedToArray3.default)(_entry[1], 1),
					    level = _entry$[0];

					return level > 0;
				}).map(function (entry) {
					var _entry2 = (0, _slicedToArray3.default)(entry, 2),
					    name = _entry2[0],
					    config = _entry2[1];

					var _config2 = (0, _slicedToArray3.default)(config, 3),
					    level = _config2[0],
					    when = _config2[1],
					    value = _config2[2];

					// Level 0 rules are ignored


					if (level === 0) {
						return null;
					}

					var rule = _rules2.default[name];

					var _rule = rule(parsed, when, value),
					    _rule2 = (0, _slicedToArray3.default)(_rule, 2),
					    valid = _rule2[0],
					    message = _rule2[1];

					return {
						level,
						valid,
						name,
						message
					};
				}).filter(Boolean);

				errors = results.filter(function (result) {
					return result.level === 2 && !result.valid;
				});
				warnings = results.filter(function (result) {
					return result.level === 1 && !result.valid;
				});

				valid = errors.length === 0;

				return $return({
					valid,
					errors,
					warnings,
					input: buildCommitMesage(parsed)
				});
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
};

module.exports = exports['default'];
//# sourceMappingURL=index.js.map