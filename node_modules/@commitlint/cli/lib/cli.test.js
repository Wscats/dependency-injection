'use strict';

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _test = require('@commitlint/test');

var _ava = require('ava');

var _ava2 = _interopRequireDefault(_ava);

var _execa = require('execa');

var _execa2 = _interopRequireDefault(_execa);

var _lodash = require('lodash.merge');

var _lodash2 = _interopRequireDefault(_lodash);

var _sander = require('sander');

var sander = _interopRequireWildcard(_sander);

var _stringToStream = require('string-to-stream');

var _stringToStream2 = _interopRequireDefault(_stringToStream);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var bin = _path2.default.join(__dirname, './cli.js');

var cli = function cli(args, options) {
	return function () {
		var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

		var c = (0, _execa2.default)(bin, args, {
			capture: ['stdout'],
			cwd: options.cwd,
			env: options.env
		});
		(0, _stringToStream2.default)(input).pipe(c.stdin);
		return c.catch(function (err) {
			return err;
		});
	};
};

(0, _ava2.default)('should throw when called without [input]', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, actual;
		return Promise.resolve(_test.git.bootstrap('fixtures/empty')).then(function ($await_1) {
			try {
				cwd = $await_1;
				return Promise.resolve(cli([], { cwd })()).then(function ($await_2) {
					try {
						actual = $await_2;
						t.is(actual.code, 1);
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('should reprint input from stdin', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, actual;
		return Promise.resolve(_test.git.bootstrap('fixtures/empty')).then(function ($await_3) {
			try {
				cwd = $await_3;
				return Promise.resolve(cli([], { cwd })('foo: bar')).then(function ($await_4) {
					try {
						actual = $await_4;
						t.true(actual.stdout.includes('foo: bar'));
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('should produce no success output with --quiet flag', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, actual;
		return Promise.resolve(_test.git.bootstrap('fixtures/empty')).then(function ($await_5) {
			try {
				cwd = $await_5;
				return Promise.resolve(cli(['--quiet'], { cwd })('foo: bar')).then(function ($await_6) {
					try {
						actual = $await_6;
						t.is(actual.stdout, '');
						t.is(actual.stderr, '');
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('should produce no success output with -q flag', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, actual;
		return Promise.resolve(_test.git.bootstrap('fixtures/empty')).then(function ($await_7) {
			try {
				cwd = $await_7;
				return Promise.resolve(cli(['-q'], { cwd })('foo: bar')).then(function ($await_8) {
					try {
						actual = $await_8;
						t.is(actual.stdout, '');
						t.is(actual.stderr, '');
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('should succeed for input from stdin without rules', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, actual;
		return Promise.resolve(_test.git.bootstrap('fixtures/empty')).then(function ($await_9) {
			try {
				cwd = $await_9;
				return Promise.resolve(cli([], { cwd })('foo: bar')).then(function ($await_10) {
					try {
						actual = $await_10;
						t.is(actual.code, 0);
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('should fail for input from stdin with rule from rc', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, actual;
		return Promise.resolve(_test.git.bootstrap('fixtures/simple')).then(function ($await_11) {
			try {
				cwd = $await_11;
				return Promise.resolve(cli([], { cwd })('foo: bar')).then(function ($await_12) {
					try {
						actual = $await_12;
						t.true(actual.stdout.includes('type must not be one of [foo]'));
						t.is(actual.code, 1);
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('should work with --config option', function (t) {
	return new Promise(function ($return, $error) {
		var file, cwd, actual;

		file = 'config/commitlint.config.js';
		return Promise.resolve(_test.git.bootstrap('fixtures/specify-config-file')).then(function ($await_13) {
			try {
				cwd = $await_13;
				return Promise.resolve(cli(['--config', file], { cwd })('foo: bar')).then(function ($await_14) {
					try {
						actual = $await_14;
						t.true(actual.stdout.includes('type must not be one of [foo]'));
						t.is(actual.code, 1);
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('should fail for input from stdin with rule from js', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, actual;
		return Promise.resolve(_test.git.bootstrap('fixtures/extends-root')).then(function ($await_15) {
			try {
				cwd = $await_15;
				return Promise.resolve(cli(['--extends', './extended'], { cwd })('foo: bar')).then(function ($await_16) {
					try {
						actual = $await_16;
						t.true(actual.stdout.includes('type must not be one of [foo]'));
						t.is(actual.code, 1);
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('should produce no error output with --quiet flag', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, actual;
		return Promise.resolve(_test.git.bootstrap('fixtures/simple')).then(function ($await_17) {
			try {
				cwd = $await_17;
				return Promise.resolve(cli(['--quiet'], { cwd })('foo: bar')).then(function ($await_18) {
					try {
						actual = $await_18;
						t.is(actual.stdout, '');
						t.is(actual.stderr, '');
						t.is(actual.code, 1);
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('should produce no error output with -q flag', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, actual;
		return Promise.resolve(_test.git.bootstrap('fixtures/simple')).then(function ($await_19) {
			try {
				cwd = $await_19;
				return Promise.resolve(cli(['-q'], { cwd })('foo: bar')).then(function ($await_20) {
					try {
						actual = $await_20;
						t.is(actual.stdout, '');
						t.is(actual.stderr, '');
						t.is(actual.code, 1);
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('should work with husky commitmsg hook and git commit', function () {
	return new Promise(function ($return, $error) {
		var cwd;
		return Promise.resolve(_test.git.bootstrap('fixtures/husky/integration')).then(function ($await_21) {
			try {
				cwd = $await_21;
				return Promise.resolve(writePkg({ scripts: { commitmsg: `${bin} -e` } }, { cwd })).then(function ($await_22) {
					try {
						return Promise.resolve((0, _execa2.default)('npm', ['install'], { cwd })).then(function ($await_23) {
							try {
								return Promise.resolve((0, _execa2.default)('git', ['add', 'package.json'], { cwd })).then(function ($await_24) {
									try {
										return Promise.resolve((0, _execa2.default)('git', ['commit', '-m', '"test: this should work"'], { cwd })).then(function ($await_25) {
											try {
												return $return();
											} catch ($boundEx) {
												return $error($boundEx);
											}
										}.bind(this), $error);
									} catch ($boundEx) {
										return $error($boundEx);
									}
								}.bind(this), $error);
							} catch ($boundEx) {
								return $error($boundEx);
							}
						}.bind(this), $error);
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('should work with husky commitmsg hook in sub packages', function () {
	return new Promise(function ($return, $error) {
		var upper, cwd;
		return Promise.resolve(_test.git.bootstrap('fixtures/husky')).then(function ($await_26) {
			try {
				upper = $await_26;
				cwd = _path2.default.join(upper, 'integration');
				return Promise.resolve(writePkg({ scripts: { commitmsg: `${bin} -e` } }, { cwd: upper })).then(function ($await_27) {
					try {
						return Promise.resolve((0, _execa2.default)('npm', ['install'], { cwd })).then(function ($await_28) {
							try {
								return Promise.resolve((0, _execa2.default)('git', ['add', 'package.json'], { cwd })).then(function ($await_29) {
									try {
										return Promise.resolve((0, _execa2.default)('git', ['commit', '-m', '"test: this should work"'], { cwd })).then(function ($await_30) {
											try {
												return $return();
											} catch ($boundEx) {
												return $error($boundEx);
											}
										}.bind(this), $error);
									} catch ($boundEx) {
										return $error($boundEx);
									}
								}.bind(this), $error);
							} catch ($boundEx) {
								return $error($boundEx);
							}
						}.bind(this), $error);
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('should work with husky via commitlint -e $GIT_PARAMS', function () {
	return new Promise(function ($return, $error) {
		var cwd;
		return Promise.resolve(_test.git.bootstrap('fixtures/husky/integration')).then(function ($await_31) {
			try {
				cwd = $await_31;
				return Promise.resolve(writePkg({ scripts: { commitmsg: `${bin} -e $GIT_PARAMS` } }, { cwd })).then(function ($await_32) {
					try {
						return Promise.resolve((0, _execa2.default)('npm', ['install'], { cwd })).then(function ($await_33) {
							try {
								return Promise.resolve((0, _execa2.default)('git', ['add', 'package.json'], { cwd })).then(function ($await_34) {
									try {
										return Promise.resolve((0, _execa2.default)('git', ['commit', '-m', '"test: this should work"'], { cwd })).then(function ($await_35) {
											try {
												return $return();
											} catch ($boundEx) {
												return $error($boundEx);
											}
										}.bind(this), $error);
									} catch ($boundEx) {
										return $error($boundEx);
									}
								}.bind(this), $error);
							} catch ($boundEx) {
								return $error($boundEx);
							}
						}.bind(this), $error);
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('should work with husky via commitlint -e %GIT_PARAMS%', function () {
	return new Promise(function ($return, $error) {
		var cwd;
		return Promise.resolve(_test.git.bootstrap('fixtures/husky/integration')).then(function ($await_36) {
			try {
				cwd = $await_36;
				return Promise.resolve(writePkg({ scripts: { commitmsg: `${bin} -e %GIT_PARAMS%` } }, { cwd })).then(function ($await_37) {
					try {
						return Promise.resolve((0, _execa2.default)('npm', ['install'], { cwd })).then(function ($await_38) {
							try {
								return Promise.resolve((0, _execa2.default)('git', ['add', 'package.json'], { cwd })).then(function ($await_39) {
									try {
										return Promise.resolve((0, _execa2.default)('git', ['commit', '-m', '"test: this should work"'], { cwd })).then(function ($await_40) {
											try {
												return $return();
											} catch ($boundEx) {
												return $error($boundEx);
											}
										}.bind(this), $error);
									} catch ($boundEx) {
										return $error($boundEx);
									}
								}.bind(this), $error);
							} catch ($boundEx) {
								return $error($boundEx);
							}
						}.bind(this), $error);
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('should pick up parser preset and fail accordingly', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, actual;
		return Promise.resolve(_test.git.bootstrap('fixtures/parser-preset')).then(function ($await_41) {
			try {
				cwd = $await_41;
				return Promise.resolve(cli(['--parser-preset', './parser-preset'], { cwd })('type(scope): subject')).then(function ($await_42) {
					try {
						actual = $await_42;
						t.is(actual.code, 1);
						t.true(actual.stdout.includes('message may not be empty [subject-empty]'));
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('should pick up parser preset and succeed accordingly', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, actual;
		return Promise.resolve(_test.git.bootstrap('fixtures/parser-preset')).then(function ($await_43) {
			try {
				cwd = $await_43;
				return Promise.resolve(cli(['--parser-preset', './parser-preset'], { cwd })('----type(scope): subject')).then(function ($await_44) {
					try {
						actual = $await_44;
						t.is(actual.code, 0);
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('should pick up config from outside git repo and fail accordingly', function (t) {
	return new Promise(function ($return, $error) {
		var outer, cwd, actual;
		return Promise.resolve(_test.fix.bootstrap('fixtures/outer-scope')).then(function ($await_45) {
			try {
				outer = $await_45;
				return Promise.resolve(_test.git.init(_path2.default.join(outer, 'inner-scope'))).then(function ($await_46) {
					try {
						cwd = $await_46;

						return Promise.resolve(cli([], { cwd })('inner: bar')).then(function ($await_47) {
							try {
								actual = $await_47;
								t.is(actual.code, 1);
								return $return();
							} catch ($boundEx) {
								return $error($boundEx);
							}
						}.bind(this), $error);
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('should pick up config from outside git repo and succeed accordingly', function (t) {
	return new Promise(function ($return, $error) {
		var outer, cwd, actual;
		return Promise.resolve(_test.fix.bootstrap('fixtures/outer-scope')).then(function ($await_48) {
			try {
				outer = $await_48;
				return Promise.resolve(_test.git.init(_path2.default.join(outer, 'inner-scope'))).then(function ($await_49) {
					try {
						cwd = $await_49;

						return Promise.resolve(cli([], { cwd })('outer: bar')).then(function ($await_50) {
							try {
								actual = $await_50;
								t.is(actual.code, 0);
								return $return();
							} catch ($boundEx) {
								return $error($boundEx);
							}
						}.bind(this), $error);
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('should pick up config from inside git repo with precedence and succeed accordingly', function (t) {
	return new Promise(function ($return, $error) {
		var outer, cwd, actual;
		return Promise.resolve(_test.fix.bootstrap('fixtures/inner-scope')).then(function ($await_51) {
			try {
				outer = $await_51;
				return Promise.resolve(_test.git.init(_path2.default.join(outer, 'inner-scope'))).then(function ($await_52) {
					try {
						cwd = $await_52;

						return Promise.resolve(cli([], { cwd })('inner: bar')).then(function ($await_53) {
							try {
								actual = $await_53;
								t.is(actual.code, 0);
								return $return();
							} catch ($boundEx) {
								return $error($boundEx);
							}
						}.bind(this), $error);
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('should pick up config from inside git repo with precedence and fail accordingly', function (t) {
	return new Promise(function ($return, $error) {
		var outer, cwd, actual;
		return Promise.resolve(_test.fix.bootstrap('fixtures/inner-scope')).then(function ($await_54) {
			try {
				outer = $await_54;
				return Promise.resolve(_test.git.init(_path2.default.join(outer, 'inner-scope'))).then(function ($await_55) {
					try {
						cwd = $await_55;

						return Promise.resolve(cli([], { cwd })('outer: bar')).then(function ($await_56) {
							try {
								actual = $await_56;
								t.is(actual.code, 1);
								return $return();
							} catch ($boundEx) {
								return $error($boundEx);
							}
						}.bind(this), $error);
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('should handle --amend with signoff', function () {
	return new Promise(function ($return, $error) {
		var cwd;
		return Promise.resolve(_test.git.bootstrap('fixtures/signoff')).then(function ($await_57) {
			try {
				cwd = $await_57;
				return Promise.resolve(writePkg({ scripts: { commitmsg: `${bin} -e` } }, { cwd })).then(function ($await_58) {
					try {
						return Promise.resolve((0, _execa2.default)('npm', ['install'], { cwd })).then(function ($await_59) {
							try {
								return Promise.resolve((0, _execa2.default)('git', ['add', 'package.json'], { cwd })).then(function ($await_60) {
									try {
										return Promise.resolve((0, _execa2.default)('git', ['commit', '-m', '"test: this should work"', '--signoff'], { cwd })).then(function ($await_61) {
											try {
												return Promise.resolve((0, _execa2.default)('git', ['commit', '--amend', '--no-edit'], { cwd })).then(function ($await_62) {
													try {
														return $return();
													} catch ($boundEx) {
														return $error($boundEx);
													}
												}.bind(this), $error);
											} catch ($boundEx) {
												return $error($boundEx);
											}
										}.bind(this), $error);
									} catch ($boundEx) {
										return $error($boundEx);
									}
								}.bind(this), $error);
							} catch ($boundEx) {
								return $error($boundEx);
							}
						}.bind(this), $error);
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('should handle linting with issue prefixes', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, actual;
		return Promise.resolve(_test.git.bootstrap('fixtures/issue-prefixes')).then(function ($await_63) {
			try {
				cwd = $await_63;
				return Promise.resolve(cli([], { cwd })('foobar REF-1')).then(function ($await_64) {
					try {
						actual = $await_64;
						t.is(actual.code, 0);
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('should print full commit message when input from stdin fails', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, input, actual;
		return Promise.resolve(_test.git.bootstrap('fixtures/simple')).then(function ($await_65) {
			try {
				cwd = $await_65;
				input = 'foo: bar\n\nFoo bar bizz buzz.\n\nCloses #123.';
				return Promise.resolve(cli([], { cwd })(input)).then(function ($await_66) {
					try {
						actual = $await_66;

						t.true(actual.stdout.includes(input));
						t.is(actual.code, 1);
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('should not print full commit message when input succeeds', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, message, actual;
		return Promise.resolve(_test.git.bootstrap('fixtures/empty')).then(function ($await_67) {
			try {
				cwd = $await_67;
				message = 'foo: bar\n\nFoo bar bizz buzz.\n\nCloses #123.';
				return Promise.resolve(cli([], { cwd })(message)).then(function ($await_68) {
					try {
						actual = $await_68;

						t.false(actual.stdout.includes(message));
						t.true(actual.stdout.includes(message.split('\n')[0]));
						t.is(actual.code, 0);
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

function writePkg(payload, options) {
	return new Promise(function ($return, $error) {
		var pkgPath, pkg, result;

		pkgPath = _path2.default.join(options.cwd, 'package.json');
		return Promise.resolve(sander.readFile(pkgPath)).then(function ($await_69) {
			try {
				pkg = JSON.parse($await_69);
				result = (0, _lodash2.default)(pkg, payload);
				return Promise.resolve(sander.writeFile(pkgPath, JSON.stringify(result, null, '  '))).then(function ($await_70) {
					try {
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
}
//# sourceMappingURL=cli.test.js.map