'use strict';

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _test = require('@commitlint/test');

var _ava = require('ava');

var _ava2 = _interopRequireDefault(_ava);

var _ = require('.');

var _2 = _interopRequireDefault(_);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _ava2.default)('extends-empty should have no rules', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, actual;
		return Promise.resolve(_test.git.bootstrap('fixtures/extends-empty')).then(function ($await_1) {
			try {
				cwd = $await_1;
				return Promise.resolve((0, _2.default)({}, { cwd })).then(function ($await_2) {
					try {
						actual = $await_2;
						t.deepEqual(actual.rules, {});
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('uses seed as configured', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, actual;
		return Promise.resolve(_test.git.bootstrap('fixtures/extends-empty')).then(function ($await_3) {
			try {
				cwd = $await_3;
				return Promise.resolve((0, _2.default)({ rules: { foo: 'bar' } }, { cwd })).then(function ($await_4) {
					try {
						actual = $await_4;
						t.is(actual.rules.foo, 'bar');
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('rules should be loaded from specify config file', function (t) {
	return new Promise(function ($return, $error) {
		var file, cwd, actual;

		file = 'config/commitlint.config.js';
		return Promise.resolve(_test.git.bootstrap('fixtures/specify-config-file')).then(function ($await_5) {
			try {
				cwd = $await_5;
				return Promise.resolve((0, _2.default)({}, { cwd, file })).then(function ($await_6) {
					try {
						actual = $await_6;
						t.is(actual.rules.foo, 'bar');
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('uses seed with parserPreset', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, _ref, actual;

		return Promise.resolve(_test.git.bootstrap('fixtures/parser-preset')).then(function ($await_7) {
			try {
				cwd = $await_7;
				return Promise.resolve((0, _2.default)({
					parserPreset: './conventional-changelog-custom'
				}, { cwd })).then(function ($await_8) {
					try {
						_ref = $await_8, actual = _ref.parserPreset;

						t.is(actual.name, './conventional-changelog-custom');
						t.deepEqual(actual.parserOpts, {
							headerPattern: /^(\w*)(?:\((.*)\))?-(.*)$/
						});
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('invalid extend should throw', function (t) {
	return new Promise(function ($return, $error) {
		var cwd;
		return Promise.resolve(_test.git.bootstrap('fixtures/extends-invalid')).then(function ($await_9) {
			try {
				cwd = $await_9;
				return Promise.resolve(t.throws((0, _2.default)({}, { cwd }))).then(function ($await_10) {
					try {
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('empty file should have no rules', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, actual;
		return Promise.resolve(_test.git.bootstrap('fixtures/empty-object-file')).then(function ($await_11) {
			try {
				cwd = $await_11;
				return Promise.resolve((0, _2.default)({}, { cwd })).then(function ($await_12) {
					try {
						actual = $await_12;
						t.deepEqual(actual.rules, {});
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('empty file should extend nothing', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, actual;
		return Promise.resolve(_test.git.bootstrap('fixtures/empty-file')).then(function ($await_13) {
			try {
				cwd = $await_13;
				return Promise.resolve((0, _2.default)({}, { cwd })).then(function ($await_14) {
					try {
						actual = $await_14;
						t.deepEqual(actual.extends, []);
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('respects cwd option', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, actual;
		return Promise.resolve(_test.git.bootstrap('fixtures/recursive-extends/first-extended')).then(function ($await_15) {
			try {
				cwd = $await_15;
				return Promise.resolve((0, _2.default)({}, { cwd })).then(function ($await_16) {
					try {
						actual = $await_16;
						t.deepEqual(actual, {
							extends: ['./second-extended'],
							rules: {
								one: 1,
								two: 2
							}
						});
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('recursive extends', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, actual;
		return Promise.resolve(_test.git.bootstrap('fixtures/recursive-extends')).then(function ($await_17) {
			try {
				cwd = $await_17;
				return Promise.resolve((0, _2.default)({}, { cwd })).then(function ($await_18) {
					try {
						actual = $await_18;
						t.deepEqual(actual, {
							extends: ['./first-extended'],
							rules: {
								zero: 0,
								one: 1,
								two: 2
							}
						});
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('recursive extends with json file', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, actual;
		return Promise.resolve(_test.git.bootstrap('fixtures/recursive-extends-json')).then(function ($await_19) {
			try {
				cwd = $await_19;
				return Promise.resolve((0, _2.default)({}, { cwd })).then(function ($await_20) {
					try {
						actual = $await_20;

						t.deepEqual(actual, {
							extends: ['./first-extended'],
							rules: {
								zero: 0,
								one: 1,
								two: 2
							}
						});
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('recursive extends with yaml file', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, actual;
		return Promise.resolve(_test.git.bootstrap('fixtures/recursive-extends-yaml')).then(function ($await_21) {
			try {
				cwd = $await_21;
				return Promise.resolve((0, _2.default)({}, { cwd })).then(function ($await_22) {
					try {
						actual = $await_22;

						t.deepEqual(actual, {
							extends: ['./first-extended'],
							rules: {
								zero: 0,
								one: 1,
								two: 2
							}
						});
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('recursive extends with js file', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, actual;
		return Promise.resolve(_test.git.bootstrap('fixtures/recursive-extends-js')).then(function ($await_23) {
			try {
				cwd = $await_23;
				return Promise.resolve((0, _2.default)({}, { cwd })).then(function ($await_24) {
					try {
						actual = $await_24;

						t.deepEqual(actual, {
							extends: ['./first-extended'],
							rules: {
								zero: 0,
								one: 1,
								two: 2
							}
						});
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('recursive extends with package.json file', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, actual;
		return Promise.resolve(_test.git.bootstrap('fixtures/recursive-extends-package')).then(function ($await_25) {
			try {
				cwd = $await_25;
				return Promise.resolve((0, _2.default)({}, { cwd })).then(function ($await_26) {
					try {
						actual = $await_26;

						t.deepEqual(actual, {
							extends: ['./first-extended'],
							rules: {
								zero: 0,
								one: 1,
								two: 2
							}
						});
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('parser preset overwrites completely instead of merging', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, actual;
		return Promise.resolve(_test.git.bootstrap('fixtures/parser-preset-override')).then(function ($await_27) {
			try {
				cwd = $await_27;
				return Promise.resolve((0, _2.default)({}, { cwd })).then(function ($await_28) {
					try {
						actual = $await_28;
						t.is(actual.parserPreset.name, './custom');
						t.deepEqual(actual.parserPreset.parserOpts, {
							headerPattern: /.*/
						});
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('recursive extends with parserPreset', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, actual;
		return Promise.resolve(_test.git.bootstrap('fixtures/recursive-parser-preset')).then(function ($await_29) {
			try {
				cwd = $await_29;
				return Promise.resolve((0, _2.default)({}, { cwd })).then(function ($await_30) {
					try {
						actual = $await_30;
						t.is(actual.parserPreset.name, './conventional-changelog-custom');
						t.is(typeof actual.parserPreset.parserOpts, 'object');
						t.deepEqual(actual.parserPreset.parserOpts.headerPattern, /^(\w*)(?:\((.*)\))?-(.*)$/);
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('ignores unknow keys', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, actual;
		return Promise.resolve(_test.git.bootstrap('fixtures/trash-file')).then(function ($await_31) {
			try {
				cwd = $await_31;
				return Promise.resolve((0, _2.default)({}, { cwd })).then(function ($await_32) {
					try {
						actual = $await_32;

						t.deepEqual(actual, {
							extends: [],
							rules: {
								foo: 'bar',
								baz: 'bar'
							}
						});
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('ignores unknow keys recursively', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, actual;
		return Promise.resolve(_test.git.bootstrap('fixtures/trash-extend')).then(function ($await_33) {
			try {
				cwd = $await_33;
				return Promise.resolve((0, _2.default)({}, { cwd })).then(function ($await_34) {
					try {
						actual = $await_34;

						t.deepEqual(actual, {
							extends: ['./one'],
							rules: {
								zero: 0,
								one: 1
							}
						});
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('find up from given cwd', function (t) {
	return new Promise(function ($return, $error) {
		var outer, cwd, actual;
		return Promise.resolve(_test.fix.bootstrap('fixtures/outer-scope')).then(function ($await_35) {
			try {
				outer = $await_35;
				return Promise.resolve(_test.git.init(_path2.default.join(outer, 'inner-scope'))).then(function ($await_36) {
					try {
						cwd = _path2.default.join(outer, 'inner-scope', 'child-scope');

						return Promise.resolve((0, _2.default)({}, { cwd })).then(function ($await_37) {
							try {
								actual = $await_37;

								t.deepEqual(actual, {
									extends: [],
									rules: {
										child: true,
										inner: false,
										outer: false
									}
								});
								return $return();
							} catch ($boundEx) {
								return $error($boundEx);
							}
						}.bind(this), $error);
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('find up config from outside current git repo', function (t) {
	return new Promise(function ($return, $error) {
		var outer, cwd, actual;
		return Promise.resolve(_test.fix.bootstrap('fixtures/outer-scope')).then(function ($await_38) {
			try {
				outer = $await_38;
				return Promise.resolve(_test.git.init(_path2.default.join(outer, 'inner-scope'))).then(function ($await_39) {
					try {
						cwd = $await_39;
						return Promise.resolve((0, _2.default)({}, { cwd })).then(function ($await_40) {
							try {
								actual = $await_40;

								t.deepEqual(actual, {
									extends: [],
									rules: {
										child: false,
										inner: false,
										outer: true
									}
								});
								return $return();
							} catch ($boundEx) {
								return $error($boundEx);
							}
						}.bind(this), $error);
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});
//# sourceMappingURL=index.test.js.map