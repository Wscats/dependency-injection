'use strict';

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _importFrom = require('import-from');

var _importFrom2 = _interopRequireDefault(_importFrom);

var _ava = require('ava');

var _ava2 = _interopRequireDefault(_ava);

var _ = require('.');

var _2 = _interopRequireDefault(_);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _ava2.default)('throws when called without params', function (t) {
	return new Promise(function ($return, $error) {
		var error;
		return Promise.resolve(t.throws((0, _2.default)())).then(function ($await_1) {
			try {
				error = $await_1;
				t.is(error.message, 'Expected a raw commit');
				return $return();
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('throws when called with empty message', function (t) {
	return new Promise(function ($return, $error) {
		var error;
		return Promise.resolve(t.throws((0, _2.default)())).then(function ($await_2) {
			try {
				error = $await_2;
				t.is(error.message, 'Expected a raw commit');
				return $return();
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('returns object with raw message', function (t) {
	return new Promise(function ($return, $error) {
		var message, actual;

		message = 'type(scope): subject';
		return Promise.resolve((0, _2.default)(message)).then(function ($await_3) {
			try {
				actual = $await_3;
				t.is(actual.raw, message);
				return $return();
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('calls parser with message and passed options', function (t) {
	return new Promise(function ($return, $error) {
		var message;

		message = 'message';

		return Promise.resolve((0, _2.default)(message, function (m) {
			t.is(message, m);
			return {};
		})).then(function ($await_4) {
			try {
				return $return();
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('passes object up from parser function', function (t) {
	return new Promise(function ($return, $error) {
		var message, result, actual;

		message = 'message';
		result = {};
		return Promise.resolve((0, _2.default)(message, function () {
			return result;
		})).then(function ($await_5) {
			try {
				actual = $await_5;
				t.is(actual, result);
				return $return();
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('returns object with expected keys', function (t) {
	return new Promise(function ($return, $error) {
		var message, actual, expected;

		message = 'message';
		return Promise.resolve((0, _2.default)(message)).then(function ($await_6) {
			try {
				actual = $await_6;
				expected = {
					body: null,
					footer: null,
					header: 'message',
					mentions: [],
					merge: null,
					notes: [],
					raw: 'message',
					references: [],
					revert: null,
					scope: null,
					subject: null,
					type: null
				};
				t.deepEqual(actual, expected);
				return $return();
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('uses angular grammar', function (t) {
	return new Promise(function ($return, $error) {
		var message, actual, expected;

		message = 'type(scope): subject';
		return Promise.resolve((0, _2.default)(message)).then(function ($await_7) {
			try {
				actual = $await_7;
				expected = {
					body: null,
					footer: null,
					header: 'type(scope): subject',
					mentions: [],
					merge: null,
					notes: [],
					raw: 'type(scope): subject',
					references: [],
					revert: null,
					scope: 'scope',
					subject: 'subject',
					type: 'type'
				};
				t.deepEqual(actual, expected);
				return $return();
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('uses custom opts parser', function (t) {
	return new Promise(function ($return, $error) {
		var message, changelogOpts, actual, expected;

		message = 'type(scope)-subject';
		return Promise.resolve((0, _importFrom2.default)(process.cwd(), './fixtures/parser-preset/conventional-changelog-custom')).then(function ($await_8) {
			try {
				changelogOpts = $await_8;
				return Promise.resolve((0, _2.default)(message, undefined, changelogOpts.parserOpts)).then(function ($await_9) {
					try {
						actual = $await_9;
						expected = {
							body: null,
							footer: null,
							header: 'type(scope)-subject',
							mentions: [],
							merge: null,
							notes: [],
							raw: 'type(scope)-subject',
							references: [],
							revert: null,
							scope: 'scope',
							subject: 'subject',
							type: 'type'
						};
						t.deepEqual(actual, expected);
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('supports scopes with /', function (t) {
	return new Promise(function ($return, $error) {
		var message, actual;

		message = 'type(some/scope): subject';
		return Promise.resolve((0, _2.default)(message)).then(function ($await_10) {
			try {
				actual = $await_10;
				t.is(actual.scope, 'some/scope');
				t.is(actual.subject, 'subject');
				return $return();
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('supports scopes with / and empty parserOpts', function (t) {
	return new Promise(function ($return, $error) {
		var message, actual;

		message = 'type(some/scope): subject';
		return Promise.resolve((0, _2.default)(message, undefined, {})).then(function ($await_11) {
			try {
				actual = $await_11;
				t.is(actual.scope, 'some/scope');
				t.is(actual.subject, 'subject');
				return $return();
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('ignores comments', function (t) {
	return new Promise(function ($return, $error) {
		var message, changelogOpts, opts, actual;

		message = 'type(some/scope): subject\n# some comment';
		return Promise.resolve((0, _importFrom2.default)(process.cwd(), 'conventional-changelog-angular')).then(function ($await_12) {
			try {
				changelogOpts = $await_12;
				opts = Object.assign({}, changelogOpts.parserOpts, { commentChar: '#' });
				return Promise.resolve((0, _2.default)(message, undefined, opts)).then(function ($await_13) {
					try {
						actual = $await_13;
						t.is(actual.body, null);
						t.is(actual.footer, null);
						t.is(actual.subject, 'subject');
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('registers inline #', function (t) {
	return new Promise(function ($return, $error) {
		var message, changelogOpts, opts, actual;

		message = 'type(some/scope): subject #reference\n# some comment\nthings #reference';
		return Promise.resolve((0, _importFrom2.default)(process.cwd(), 'conventional-changelog-angular')).then(function ($await_14) {
			try {
				changelogOpts = $await_14;
				opts = Object.assign({}, changelogOpts.parserOpts, { commentChar: '#' });
				return Promise.resolve((0, _2.default)(message, undefined, opts)).then(function ($await_15) {
					try {
						actual = $await_15;
						t.is(actual.subject, 'subject #reference');
						t.is(actual.body, 'things #reference');
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('parses references leading subject', function (t) {
	return new Promise(function ($return, $error) {
		var message, opts, _ref, _ref$references, actual;

		message = '#1 some subject';
		return Promise.resolve((0, _importFrom2.default)(process.cwd(), 'conventional-changelog-angular')).then(function ($await_16) {
			try {
				opts = $await_16;
				return Promise.resolve((0, _2.default)(message, undefined, opts)).then(function ($await_17) {
					try {
						_ref = $await_17, _ref$references = (0, _slicedToArray3.default)(_ref.references, 1), actual = _ref$references[0];

						t.is(actual.issue, '1');
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('parses custom references', function (t) {
	return new Promise(function ($return, $error) {
		var message, _ref2, references;

		message = '#1 some subject PREFIX-2';
		return Promise.resolve((0, _2.default)(message, undefined, {
			issuePrefixes: ['PREFIX-']
		})).then(function ($await_18) {
			try {
				_ref2 = $await_18, references = _ref2.references;


				t.falsy(references.find(function (ref) {
					return ref.issue === '1';
				}));
				t.deepEqual(references.find(function (ref) {
					return ref.issue === '2';
				}), {
					action: null,
					issue: '2',
					owner: null,
					prefix: 'PREFIX-',
					raw: '#1 some subject PREFIX-2',
					repository: null
				});
				return $return();
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});
//# sourceMappingURL=index.test.js.map