"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
/**
 * Filter failures for the given document
 */
function filterProblemsForFile(filePath, failures) {
    const normalizedPath = path_1.normalize(filePath);
    // we only show diagnostics targetting this open document, some tslint rule return diagnostics for other documents/files
    const normalizedFiles = new Map();
    return failures.filter(each => {
        const fileName = each.getFileName();
        if (!normalizedFiles.has(fileName)) {
            normalizedFiles.set(fileName, path_1.normalize(fileName));
        }
        return normalizedFiles.get(fileName) === normalizedPath;
    });
}
exports.filterProblemsForFile = filterProblemsForFile;
function getReplacements(fix) {
    if (!fix) {
        return [];
    }
    else if (Array.isArray(fix)) {
        return fix;
    }
    else {
        return [fix];
    }
}
exports.getReplacements = getReplacements;
function getReplacement(failure, at) {
    return getReplacements(failure.getFix())[at];
}
function sortFailures(failures) {
    // The failures.replacements are sorted by position, we sort on the position of the first replacement
    return failures.sort((a, b) => {
        return getReplacement(a, 0).start - getReplacement(b, 0).start;
    });
}
exports.sortFailures = sortFailures;
function getNonOverlappingReplacements(failures) {
    function overlaps(a, b) {
        return a.end >= b.start;
    }
    const sortedFailures = sortFailures(failures);
    const nonOverlapping = [];
    for (let i = 0; i < sortedFailures.length; i++) {
        const replacements = getReplacements(sortedFailures[i].getFix());
        if (i === 0 || !overlaps(nonOverlapping[nonOverlapping.length - 1], replacements[0])) {
            nonOverlapping.push(...replacements);
        }
    }
    return nonOverlapping;
}
exports.getNonOverlappingReplacements = getNonOverlappingReplacements;
//# sourceMappingURL=failures.js.map