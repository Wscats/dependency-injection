"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const config_1 = require("./config");
class ConfigurationManager {
    constructor(_ts) {
        this._ts = _ts;
        this._configUpdatedListeners = new Set();
        this._configuration = ConfigurationManager.defaultConfig;
    }
    get config() { return this._configuration; }
    updateFromPluginConfig(config) {
        const configFile = config.configFile && !path.isAbsolute(config.configFile) && this._workingDirectory
            ? path.join(this._workingDirectory, config.configFile)
            : config.configFile;
        this._configuration = Object.assign({}, ConfigurationManager.defaultConfig, config, { configFile });
        for (const listener of this._configUpdatedListeners) {
            listener();
        }
    }
    setProject(project, logger) {
        if (this._watcher) {
            this._watcher.close();
            this._watcher = undefined;
        }
        // Watch config file for changes
        if (project instanceof this._ts.server.ConfiguredProject && this._ts.sys.watchFile) {
            const configFile = project.getConfigFilePath();
            logger.info(`ConfigurationManager: Found configured project: ${configFile}`);
            this._watcher = this._ts.sys.watchFile(configFile, (_fileName, eventKind) => {
                if (eventKind !== this._ts.FileWatcherEventKind.Changed) {
                    return;
                }
                logger.info('ConfigurationManager: file changed');
                const newConfig = loadSettingsFromTsConfig(this._ts, configFile, logger);
                if (!newConfig) {
                    logger.info(`ConfigurationManager: Could not read new config`);
                    return;
                }
                logger.info(`ConfigurationManager: Updating config settings: ${JSON.stringify(newConfig)}`);
                this.updateFromPluginConfig(newConfig);
            });
        }
        this._workingDirectory = project.getCurrentDirectory();
        this.updateFromPluginConfig(this.config);
    }
    onUpdatedConfig(listener) {
        this._configUpdatedListeners.add(listener);
    }
}
ConfigurationManager.defaultConfig = {
    alwaysShowRuleFailuresAsWarnings: true,
    ignoreDefinitionFiles: true,
    jsEnable: false,
    suppressWhileTypeErrorsPresent: false,
};
exports.ConfigurationManager = ConfigurationManager;
function loadSettingsFromTsConfig(ts, configFilePath, logger) {
    const configFileResult = ts.readConfigFile(configFilePath, ts.sys.readFile);
    if (configFileResult.error || !configFileResult.config) {
        logger.info(`ConfigurationManager: Could not read new config: ${configFileResult.error}`);
        return undefined;
    }
    if (!configFileResult.config.compilerOptions || !Array.isArray(configFileResult.config.compilerOptions.plugins)) {
        logger.info(`ConfigurationManager: Could not read new config plugins`);
        return undefined;
    }
    const pluginSettings = configFileResult.config.compilerOptions.plugins.find(x => x.name === config_1.pluginId);
    if (!pluginSettings) {
        logger.info(`ConfigurationManager: Could not read new config tslint-plugin`);
        return undefined;
    }
    return pluginSettings;
}
exports.loadSettingsFromTsConfig = loadSettingsFromTsConfig;
//# sourceMappingURL=settings.js.map