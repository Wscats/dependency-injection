"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var fs_1 = require("fs");
var path_1 = require("path");
var compiler_utils_1 = require("./compiler-utils");
exports.compileUsingTranspileModule = function (configs, logger) {
    logger.debug('compileUsingTranspileModule(): create typescript compiler');
    var _a = configs.typescript, options = _a.options, projectReferences = _a.projectReferences, fileNames = _a.fileNames;
    var files = new Map();
    var compiler = configs.compilerModule;
    fileNames.forEach(function (filePath) {
        var normalizedFilePath = path_1.normalize(filePath);
        files.set(normalizedFilePath, {
            text: fs_1.readFileSync(normalizedFilePath, 'utf-8'),
            version: 0,
        });
    });
    var program = projectReferences
        ? compiler.createProgram({
            rootNames: fileNames,
            options: options,
            projectReferences: projectReferences,
        })
        : compiler.createProgram([], options);
    var updateFileInCache = function (contents, filePath) {
        var file = files.get(filePath);
        if (file && file.text !== contents) {
            file.version++;
            file.text = contents;
        }
    };
    return {
        compileFn: function (code, fileName) {
            var normalizedFileName = path_1.normalize(fileName);
            logger.debug({ normalizedFileName: normalizedFileName }, 'getOutput(): compiling as isolated module');
            updateFileInCache(code, normalizedFileName);
            var referencedProject = compiler_utils_1.getAndCacheProjectReference(normalizedFileName, program, files, projectReferences);
            if (referencedProject !== undefined) {
                var _a = __read([
                    configs.resolvePath(referencedProject.sourceFile.fileName),
                    configs.resolvePath(normalizedFileName),
                ], 2), relativeProjectConfigPath = _a[0], relativeFilePath = _a[1];
                if (referencedProject.commandLine.options.outFile !== undefined) {
                    throw new Error("The referenced project at " + relativeProjectConfigPath + " is using " +
                        "the outFile' option, which is not supported with ts-jest.");
                }
                var jsFileName = compiler_utils_1.getAndCacheOutputJSFileName(normalizedFileName, referencedProject, files);
                var relativeJSFileName = configs.resolvePath(jsFileName);
                if (!compiler.sys.fileExists(jsFileName)) {
                    throw new Error("Could not find output JavaScript file for input " +
                        (relativeFilePath + " (looked at " + relativeJSFileName + ").\n") +
                        "The input file is part of a project reference located at " +
                        (relativeProjectConfigPath + ", so ts-jest is looking for the ") +
                        'projectâ€™s pre-built output on disk. Try running `tsc --build` ' +
                        'to build project references.');
                }
                var mapFileName = jsFileName + ".map";
                var outputText = compiler.sys.readFile(jsFileName);
                var sourceMapText = compiler.sys.readFile(mapFileName);
                return [outputText, sourceMapText];
            }
            else {
                var result = compiler.transpileModule(code, {
                    fileName: normalizedFileName,
                    transformers: configs.tsCustomTransformers,
                    compilerOptions: options,
                    reportDiagnostics: configs.shouldReportDiagnostic(normalizedFileName),
                });
                if (result.diagnostics && configs.shouldReportDiagnostic(normalizedFileName)) {
                    configs.raiseDiagnostics(result.diagnostics, normalizedFileName, logger);
                }
                return [result.outputText, result.sourceMapText];
            }
        },
        program: program,
    };
};
