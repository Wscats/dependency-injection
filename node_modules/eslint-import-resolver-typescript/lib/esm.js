import path from 'path';
import { loadConfig, createMatchPath } from 'tsconfig-paths';
import globSync from 'tiny-glob/sync';
import isGlob from 'is-glob';
import { isCore, sync } from 'resolve';
import debug from 'debug';

var log = debug('eslint-import-resolver-ts');
var extensions = ['.ts', '.tsx', '.d.ts'].concat(
// eslint-disable-next-line node/no-deprecated-api
Object.keys(require.extensions), '.jsx');
var interfaceVersion = 2;
/**
 * @param {string} source the module to resolve; i.e './some-module'
 * @param {string} file the importing file's full path; i.e. '/usr/local/bin/file.js'
 */
function resolve(source, file, options) {
    if (options === void 0) { options = {}; }
    log('looking for:', source);
    // don't worry about core node modules
    if (isCore(source)) {
        log('matched core:', source);
        return {
            found: true,
            path: null,
        };
    }
    initMappers(options);
    var mappedPath = getMappedPath(source, file);
    if (mappedPath) {
        log('matched ts path:', mappedPath);
    }
    // note that even if we map the path, we still need to do a final resolve
    var foundNodePath;
    try {
        foundNodePath = sync(mappedPath || source, {
            extensions: extensions,
            basedir: path.dirname(path.resolve(file)),
            packageFilter: packageFilter,
        });
    }
    catch (err) {
        foundNodePath = null;
    }
    // naive attempt at @types/* resolution,
    // if path is neither absolute nor relative
    if ((/\.jsx?$/.test(foundNodePath) ||
        (options.alwaysTryTypes && !foundNodePath)) &&
        !/^@types[/\\]/.test(source) &&
        !path.isAbsolute(source) &&
        !source.startsWith('.')) {
        var definitelyTyped = resolve('@types' + path.sep + mangleScopedPackage(source), file, options);
        if (definitelyTyped.found) {
            return definitelyTyped;
        }
    }
    if (foundNodePath) {
        log('matched node path:', foundNodePath);
        return {
            found: true,
            path: foundNodePath,
        };
    }
    log("didn't find ", source);
    return {
        found: false,
    };
}
function packageFilter(pkg) {
    pkg.main =
        pkg.types || pkg.typings || pkg.module || pkg['jsnext:main'] || pkg.main;
    return pkg;
}
var mappers;
/**
 * @param {string} source the module to resolve; i.e './some-module'
 * @param {string} file the importing file's full path; i.e. '/usr/local/bin/file.js'
 * @returns The mapped path of the module or undefined
 */
function getMappedPath(source, file) {
    var paths = mappers
        .map(function (mapper) { return mapper(source, file); })
        .filter(function (path) { return !!path; });
    if (paths.length > 1) {
        log('found multiple matching ts paths:', paths);
    }
    return paths[0];
}
function initMappers(options) {
    if (mappers) {
        return;
    }
    var isArrayOfStrings = function (array) {
        return Array.isArray(array) && array.every(function (o) { return typeof o === 'string'; });
    };
    var configPaths = typeof options.directory === 'string'
        ? [options.directory]
        : isArrayOfStrings(options.directory)
            ? options.directory
            : [process.cwd()];
    mappers = configPaths
        // turn glob patterns into paths
        .reduce(function (paths, path) { return paths.concat(isGlob(path) ? globSync(path) : path); }, [])
        .map(loadConfig)
        .filter(isConfigLoaderSuccessResult)
        .map(function (configLoaderResult) {
        var matchPath = createMatchPath(configLoaderResult.absoluteBaseUrl, configLoaderResult.paths);
        return function (source, file) {
            // exclude files that are not part of the config base url
            if (!file.includes(configLoaderResult.absoluteBaseUrl)) {
                return undefined;
            }
            // look for files based on setup tsconfig "paths"
            return matchPath(source, undefined, undefined, extensions);
        };
    });
}
function isConfigLoaderSuccessResult(configLoaderResult) {
    if (configLoaderResult.resultType !== 'success') {
        // this can happen if the user has problems with their tsconfig
        // or if it's valid, but they don't have baseUrl set
        log('failed to init tsconfig-paths:', configLoaderResult.message);
        return false;
    }
    return true;
}
/**
 * For a scoped package, we must look in `@types/foo__bar` instead of `@types/@foo/bar`.
 */
function mangleScopedPackage(moduleName) {
    if (moduleName.startsWith('@')) {
        var replaceSlash = moduleName.replace(path.sep, '__');
        if (replaceSlash !== moduleName) {
            return replaceSlash.slice(1); // Take off the "@"
        }
    }
    return moduleName;
}

export { interfaceVersion, resolve };
